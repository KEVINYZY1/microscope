总体考虑

1 低开销 
开销来源：生成跟踪消息 + 异步线程发送消息 + 内存，未来考虑kafka作为消息中间件。 
2 对应用程序透明
将跟踪组件封装在框架中，对应用程序透明。
3 扩展性
采用Hbase + zookeeper 结构，水平扩展。

###########################################################################################
依赖的资源 

1 在pom.xml中添加microscope-framework.jar
maven 地址
<dependency>
  	<groupId>com.vipshop</groupId>
  	<artifactId>microscope-framework</artifactId>
  	<version>1.0.5</version>
</dependency>

2 在类加载路径下添加trace.properties 文件
文件内容如下，需要修改app_name选项，以下是招商选品,
                                     线上环境需要配置IP ************** 
                                     测试环境可以配置IP **************

app_name=picket
collector_host=microscope.collector .com     
collector_port=9410
max_batch_size=100
max_empty_size=100
switch=1
queue_size=10000
reconnect_wait_time=3000
send_wait_time=100

###########################################################################################
封装Servlet

在web.xml中配置filter:com.vipshop.microscope.framework.filter.MicroscopeFilter

###########################################################################################
封装SpringMVC Controller

在Spring配置文件中，配置拦截器。

<bean id="controllerInterception" class="com.vipshop.microscope.framework.spring.MicroscopeSpringMVCInterceptor" />

<bean class="org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping">
        <property name="interceptors">
            <list>
                <ref bean="controllerInterception"/>
            </list>
        </property>
</bean>

###########################################################################################
封装resteasy框架

在spring配置文件中，注入以下两个类：

com.vipshop.microscope.framework.restful.MicroscopePostInterceptor
com.vipshop.microscope.framework.restful.MicroscopePreInterceptor

###########################################################################################
封装Service层

在spring配置文件中配置AOP代理

<beann id="mircoscopeAspect" class="com.vipshop.user.info.aop.MicroscopeAspect"/>

<aop:config>
    <aop:aspect id="microscope" ref="mircoscopeAspect">
		<aop:pointcut id="businessService" expression="execution(*com.vipshop.user.info.service.*.*(..))" />
    	<aop:before pointcut-ref="businessService" method="doBefore"/>
    	<aop:after pointcut-ref="businessService" method="doAfter"/>
    </aop:aspect>
</aop:config>

###########################################################################################
封装MyBATIS DAO层

在mybatis-config.xml 文件中加入插件
serverIP 代表数据库地址/名称
	
<plugins>
	<plugin interceptor="com.vipshop.microscope.framework.mybatis.MicroscopeMyBatisInterceptor">
		<property name="serverIP" value="db@test" />
	</plugin>
</plugins>

###########################################################################################
封装线程异步调用

线程异步调用会丢失跟踪的上下文，需要显示关联
1 在开启新的线程之前获取上下文
Trace contexTrace = Tracer.getContext();
2 在线程run()方法中第一行设置上下文
Tracer.setContext(contexTrace);

###########################################################################################
封装Http请求客户端

由于跨JVM的RPC调用会丢失跟踪上下文，因为需要传递上下文。
对于HTTP请求，使用定制版本的HttpClient jar
maven地址
<dependency>
	<groupId>org.apache.httpcomponents</groupId>
	<artifactId>httpclient</artifactId>
	<version>4.2</version>
	<classifier>microscope-1.0.5</classifier>
	<exclusions>
		<exclusion>
			<groupId>org.apache.httpcomponents</groupId>
			<artifactId>httpclient</artifactId>
		</exclusion>
	</exclusions>
</dependency>

###########################################################################################
封装HTTP请求服务器端

服务器端需要从HTTP头中获取
Trace ID
Span ID

服务器端：spring ---- 配置SpringMVC Controller
         thrift ---- 配置 ThriftServer
 
###########################################################################################        
封装Thrift请求客户端

对于Thrfit请求：我们了解到passport 使用的thrift本质上使用httpclient进行调用，
因此使用定制httpclient版本即可。

注意事项：Thrift 0.9.0 依赖 httpclient 4.1.3, 需要显示的排除这个依赖。

###########################################################################################
封装Thrift请求服务器端 

目前passport团队的thrift服务器处理机制：
类：ThriftRequestHandler +
方法：public void handleRequest(HttpServletRequest request, HttpServletResponse response)

passport开发人员需要在handleRequest方法中调用
Tracer.clientSend(request, Category.METHOD)
+ 原始的业务代码
Tracer.clientReceive()

###########################################################################################
异常信息关联处理

当应用程序发生异常时，可以将trace id 记录在异常信息中，这样就可以关联到microscope web 界面，查看此异常信息发生的整个调用链。

调用API 
Tracer.getTraceId()
访问URL，
http://microscope.vipshop.com./#/show/-6201428382076202241

###########################################################################################
对于自定义调试信息

microscope可以定位某一个方法或者service或着dao方法或者cache访问很慢；但是不能知道究竟是什么原因导致慢。
开发人员可以通过API：
Tracer.record(“key”, “value”) 
将可能导致调用慢的信息关联到调用链，用于诊断、调试,这是一个可选项。

###########################################################################################
手动埋点

如果开发人员对某一代码块执行感兴趣，可以手动埋点

@Test
public void traceUseExample() throws InterruptedException {

Tracer.clientSend("example", Category.METHOD);

try {
    TimeUnit.SECONDS.sleep(1);
    System.out.println("example method invoke");
    throw new RuntimeException();
} catch (Exception e) {
    Tracer.setResultCode(ResultCode.EXCEPTION);
} finally {
    Tracer.clientReceive();
}

TimeUnit.SECONDS.sleep(10);
}

###########################################################################################
其他框架

后续框架接入封装思路：

对于提供拦截器功能的框架，我们提供拦截器
对于直接调用的框架，我们提供定制版本的jar

基本上可以做到一次配置，后续透明。
埋点、封装的工作会结合实际团队所使用的技术，实践起来需要开发团队提供支持。


microscope java client 设计指南

###############################################################################
设计指标

客户端需要支持多语言：client需要跟踪java用于和PHP应用
客户端不能影响主程序
客户端不需要保证消息发送的绝对可靠性
客户端能够自动重连接到collector
客户端需要对消息压缩、批量发送
客户端需要封装在框架中
客户端应该能够被开启或者关闭：通过zookeeper实现
客户端在应对大数据的时候应该能够采样
客户端对应用程序的性能消耗应该尽量低
客户端对异步线程需要关联上下文

###############################################################################
设计方案

初期: Queue + Thread + TCP

使用 Jdk Queue 作为消息存储缓冲区；
使用守护线程发送消息；
使用TCP连接collector；

未来：考虑到大量应用的接入：考虑使用kafka作为消息中间件

###############################################################################
实现参考

当客户端的代码被执行的时候，跟踪程序都会相应的被执行；
因此，我们认为：跟踪程序是与线程一致的。

跟踪程序需要保证再一次跟踪中有唯一的跟踪ID。

跟踪程序在跨JVM远程调用时，需要传递跟踪ID。

综上所述：我们实现了microscope java client.


